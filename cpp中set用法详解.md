[toc]
## **1.关于set**

C++ `STL` 之所以得到广泛的赞誉，也被很多人使用，不只是提供了像`vector`,`string`, `list`等方便的容器，更重要的是`STL`封装了许多复杂的数据结构算法和大量常用数据结构操作。

`vector`封装数组，`list`封装了链表，`map`和`set`封装了二叉树等，在封装这些数据结构的时候，STL按照程序员的使用习惯，以成员函数方式提供的常用操作，如：**插入、排序、删除、查找**等。让用户在`STL`使用过程中，并不会感到陌生。

关于`set`，必须说明的是**set关联式容器**。`set`作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在`set`中每个元素的值都**唯一**，而且系统能根据元素的值**自动进行排序**。应该注意的是`set`中数元素的**值不能直接被改变**。

C++ STL中标准关联容器`set`,`multiset`, `map`, `multimap`内部采用的就是一种非常高效的**平衡检索二叉树**：红黑树，也成为**RB树(Red-Black Tree)**。RB树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。

### **关于set有下面几个问题：**

#### 为何map和set的插入删除效率比用其他序列容器高？

大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。`set`容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：

 ```
 　　A
　  / \
　 B   C
　/ \ / \
  D E F G
 ```

因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。

#### 为何每次insert之后，以前保存的iterator不会失效

`iterator`这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于`vector`来说，每一次删除和插入，指针都有可能失效，调用`push_back`在尾部插入也是如此。

因为为了保证内部数据的连续存放，`iterator`指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使`push_back`的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和 `find`等算法在一起使用的时候，牢记这个原则：不要使用过期的`iterator`。

#### 当数据元素增多时，set的插入和搜索速度变化如何？

如果你知道`log2`关系你应该就彻底了解这个答案。在`set`中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。**那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。**看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。

### set中常用的方法

------
1. begin()--返回指向第一个元素的迭代器

2. clear()--清除所有元素

3. count()--返回某个值元素的个数

4. empty()--如果集合为空，返回true

5. end()--返回指向最后一个元素的迭代器

6. equal_range()--返回集合中与给定值相等的上下限的两个迭代器

7. erase()--删除集合中的元素

8. find()--返回一个指向被查找到元素的迭代器

9. get_allocator()--返回集合的分配器

10. insert()--在集合中插入元素

11. lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器

12. key_comp()--返回一个用于元素间值比较的函数

13. max_size()--返回集合能容纳的元素的最大限值

14. rbegin()--返回指向集合中最后一个元素的反向迭代器

15. rend()--返回指向集合中第一个元素的反向迭代器

16. size()--集合中元素的数目

17. swap()--交换两个集合变量

18. upper_bound()--返回大于某个值元素的迭代器

19. value_comp()--返回一个用于比较元素间的值的函数

写一个程序练一练这几个简单操作吧： 

```cpp
#include <iostream>
#include <set>
using namespace std;
int main(){
    set<int> s;
    s.insert(1);
    s.insert(2);
    s.insert(3);
    s.insert(1);
    cout<<"set 的 size 值为 ："<<s.size()<<endl;
    cout<<"set 的 maxsize的值为 ："<<s.max_size()<<endl;
     cout<<"set 中的第一个元素是 ："<<*s.begin()<<endl;
    cout<<"set 中的最后一个元素是:"<<*s.end()<<endl;
    s.clear();
    if(s.empty())
    {
        cout<<"set 为空 ！！！"<<endl;
    }
    cout<<"set 的 size 值为 ："<<s.size()<<endl;
    cout<<"set 的 maxsize的值为 ："<<s.max_size()<<endl;
    return 0;
}
```

**小结：**插入3之后虽然插入了一个1，但是我们发现set中最后一个值仍然是3哈，这就是set 。还要注意begin() 和 end()函数是不检查set是否为空的，使用前最好使用empty()检验一下set是否为空.