

## 1. 获取目录文件列表和数目

```python
import glob
# path_file_number=glob.glob('D:/case/test/testcase/checkdata/*.py')#或者指定文件下个数
path_file_number=glob.glob(pathname='*.py') #获取当前文件夹下个数
print(path_file_number)
print(len(path_file_number))
```

python快速随机复制文件到另一个文件夹

```python
import os
import re
import random
from shutil import copy
root = "/home//"
files_list = [os.path.join(root,filename) for filename in os.listdir(root) if ".png" in filename]
random.shuffle(files_list)
fl = files_list[:100]
for file in fl:
    copy(file,"/home/")
print("done")
```



## 2. numpy交换维度

### 2.1 法一

```python
#numpy.swapaxes
x = np.array([[1,2,3]])
np.swapaxes(x,0,1)

array([[1],
       [2],
       [3]])
```

### 2.2 法二

```python
image = Image.open("myimage.png")
pixels = np.asarray(image).transpose(2,0,1)
```



## 3. numpy基操

### 3.1 创建矩阵

Numpy库中的矩阵模块为ndarray对象，有很多属性：`T`，`data`, `dtype`,`flags`,`flat`,`imag`,`real`,`size`,`itemsize`,`nbytes`,`ndim`,`shape`,`strides`,`ctypes`,`base`等等。

#### 3.1.1采用ndarray对象

```python
import numpy as np #引入numpy库

#创建一维的narray对象
a = np.array([1,2,3,4,5])

#创建二维的narray对象
a2 = np.array([[1,2,3,4,5],[6,7,8,9,10]])

#创建多维对象以其类推
```

#### 3.1.2 通过函数创建矩阵

##### arange

```python
import numpy as np

a = np.arange(10) # 默认从0开始到10（不包括10），步长为1
print(a) # 返回 [0 1 2 3 4 5 6 7 8 9]

a1 = np.arange(5,10) # 从5开始到10（不包括10），步长为1
print(a1) # 返回 [5 6 7 8 9]

a2 = np.arange(5,20,2) # 从5开始到20（不包括20），步长为2
print(a2) # 返回 [ 5  7  9 11 13 15 17 19]
```

##### linspace

创建指定数量等间隔的序列，实际生成一个等差数列。

```python
import numpy as np
a = np.linspace(0,10,5) # 生成首位是0，末位是10，含5个数的等差数列
print(a)
```

##### logspace

linspace用于生成等差数列，而logspace用于生成等比数列。 下面的例子用于生成首位是1，末位是100，含5个数的等比数列。

```python
import numpy as np
a = np.logspace(0,2,5) # 10的0次方 ，10的2次方
print(a)
```

##### ones,zeros,eye,empty

ones创建全1矩阵 
zeros创建全0矩阵 
eye创建单位矩阵 
empty创建空矩阵（实际有值）

```python
import numpy as np

a_ones = np.ones((3,4)) # 创建3*4的全1矩阵
print(a_ones)
# 结果
[[ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]
 [ 1.  1.  1.  1.]]

a_zeros = np.zeros((3,4)) # 创建3*4的全0矩阵
print(a_zeros)
# 结果
[[ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]
 [ 0.  0.  0.  0.]]

a_eye = np.eye(3) # 创建3阶单位矩阵
print(a_eye)
# 结果
[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]

a_empty = np.empty((3,4)) # 创建3*4的空矩阵
print(a_empty)
# 结果
[[  1.78006111e-306  -3.13259416e-294   4.71524461e-309   1.94927842e+289]
 [  2.10230387e-309   5.42870216e+294   6.73606381e-310   3.82265219e-297]
 [  6.24242356e-309   1.07034394e-296   2.12687797e+183   6.88703165e-315]]
```

##### fromstring

fromstring()方法可以将字符串转化成ndarray对象，需要将字符串数字化时这个方法比较有用，可以获得字符串的ascii码序列。

```python
a = "abcdef"
b = np.fromstring(a,dtype=np.int8) # 因为一个字符为8位，所以指定dtype为np.int8
print(b) # 返回 [ 97  98  99 100 101 102] 
```

##### fromfunction

fromfunction()方法可以根据矩阵的行号列号生成矩阵的元素。 例如创建一个矩阵，矩阵中的每个元素都为行号和列号的和。

```python
import numpy as np
def func(i,j):
    return i+j

a = np.fromfunction(func,(5,6))
# 第一个参数为指定函数，第二个参数为列表list或元组tuple,说明矩阵的大小
# 返回
[[ 0.  1.  2.  3.  4.  5.]
 [ 1.  2.  3.  4.  5.  6.]
 [ 2.  3.  4.  5.  6.  7.]
 [ 3.  4.  5.  6.  7.  8.]
 [ 4.  5.  6.  7.  8.  9.]]
#注意这里行号的列号都是从0开始的
```



### 3.2 矩阵的操作

numpy中的ndarray对象重载了许多运算符，使用这些运算符可以完成矩阵间对应元素的运算。

如 `+`，`-`，`*`，`/`，`%`，`**`

#### 3.2.1 矩阵的函数操作

#####  常用数学运算

| 矩阵函数     | 说明                                |
| ------------ | ----------------------------------- |
| np.sin(a)    | 对矩阵a中每个元素取正弦,sin(x)      |
| np.cos(a)    | 对矩阵a中每个元素取余弦,cos(x)      |
| np.tan(a)    | 对矩阵a中每个元素取正切,tan(x)      |
| np.arcsin(a) | 对矩阵a中每个元素取反正弦,arcsin(x) |
| np.arccos(a) | 对矩阵a中每个元素取反余弦,arccos(x) |
| np.arctan(a) | 对矩阵a中每个元素取反正切,arctan(x) |
| np.exp(a)    | 对矩阵a中每个元素取指数函数,ex      |
| np.sqrt(a)   | 对矩阵a中每个元素开根号√x           |

##### 矩阵乘法（点乘）

矩阵乘法必须满足矩阵乘法的条件，即**第一个矩阵的列数等于第二个矩阵的行数**。 矩阵乘法的函数为 dot 

```python
import numpy as np

a1 = np.array([[1,2,3],[4,5,6]]) # a1为2*3矩阵
a2 = np.array([[1,2],[3,4],[5,6]]) # a2为3*2矩阵

print(a1.shape[1]==a2.shape[0]) # True, 满足矩阵乘法条件
print(a1.dot(a2))
# a1.dot(a2)相当于matlab中的a1*a2
# 而python中的a1*a2相当于matlab中的a1.*a2
# 结果
[[22 28]
 [49 64]]
```

##### 矩阵的转置(transpose或T)

```python
import numpy as np
array=np.array([[1,2,3],
                [4,5,6]])
print(array.transpose())#或np.transpose(array)
print(array.T)
# 结果
# [[1 4]
#  [2 5]
#  [3 6]]
#           transpose与T效果一样
# [[1 4]
#  [2 5]
#  [3 6]]
```

##### 矩阵的逆

求矩阵的逆需要先导入`numpy.linalg`，用linalg的inv函数来求逆。 
矩阵求逆的条件是矩阵的行数和列数相同。

```python
import numpy as np
import numpy.linalg as lg

a = np.array([[1,2,3],[4,5,6],[7,8,9]])

print(lg.inv(a))
# 结果
[[ -4.50359963e+15   9.00719925e+15  -4.50359963e+15]
 [  9.00719925e+15  -1.80143985e+16   9.00719925e+15]
 [ -4.50359963e+15   9.00719925e+15  -4.50359963e+15]]

a = np.eye(3) # 3阶单位矩阵
print(lg.inv(a)) # 单位矩阵的逆为他本身
# 结果
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
```

##### 最大值最小值平均值方差标准差

获得矩阵中元素最大最小值的函数分别是`max`和`min`，可以获得整个矩阵、行或列的最大最小值。

获得矩阵中元素的平均值可以通过函数`mean()或average()`。同样地，可以获得整个矩阵、行或列的平均值。

方差的函数为`var()`,方差函数`var()`相当于函数`mean(abs(x - x.mean())**2)`,其中x为矩阵。

标准差的函数为`std()`。 `std()`相当于`sqrt(mean(abs(x - x.mean())**2))`，或相当于`sqrt(x.var())`。

```python
import numpy as np
array=np.array([[1,2,3],
                [4,5,6]])
print(array.max())#结果为6
print(array.min())#结果为1
#同时还可以指定axis关键字，获取行或列的最大、最小值
print(array.max(axis=0)) #x轴最大值，0,1分别代表行列

array=np.array([[1,2,3],
                [4,5,6]])
print(array.mean())#结果为3.5
print(np.average(array))#结果为3.5
print(array.mean(axis=0))#行方向的平均值，同样，0,1代表维度

# 方差
array=np.array([[1,2,3],
                [4,5,6]])
print(array.var())#结果为2.91666666667
#同样可通过axis指定维度0,1分别代表行列，
print(array.var(axis=0))
# 结果
# [ 2.25  2.25  2.25]

# 标准差
array=np.array([[1,2,3],
                [4,5,6]])
print(array.std())#结果为1.70782512766
#同样可通过axis指定维度0,1分别代表行列，
print(array.std(axis=0))
# 结果
# [ 1.5  1.5  1.5]
```

##### 中位数or中值

中值指的是将序列按大小顺序排列后，排在中间的那个值，如果有偶数个数，则是排在中间两个数的平均值。

例如序列[5,2,6,4,2]，按大小顺序排成 [2,2,4,5,6]，排在中间的数是4，所以这个序列的中值是4。

又如序列[5,2,6,4,3,2]，按大小顺序排成 [2,2,3,4,5,6]，因为有偶数个数，排在中间两个数是3、4，所以这个序列中值是3.5。

中值的函数是median()，调用方法为numpy.median(x,[axis])，axis可指定轴方向，默认axis=None，对所有数去中值

```python
import numpy as np
array=np.array([[1,2,3],
                [4,5,6]])
print(np.median(array))#结果：3.5
#指定维度
print(np.median(array,axis=0))
#结果
# [ 2.5  3.5  4.5]
```

##### 求和

矩阵求和的函数是sum()，可以对行，列，或整个矩阵求和。

```python
import numpy as np
array=np.array([[1,2,3],
                [4,5,6]])
print(array.sum())#结果：21
#指定维度
print(array.sum(axis=0))
#结果
# [5 7 9]
```

##### 累计和或累加

某位置累积和指的是该位置之前(包括该位置)所有元素的和。

例如序列[1,2,3,4,5]，其累计和为[1,3,6,10,15]，即第一个元素为1，第二个元素为1+2=3，……，第五个元素为1+2+3+4+5=15。

矩阵求累积和的函数是`cumsum()`，可以对行，列，或整个矩阵求累积和。

```python
import numpy as np

a = np.array([[1,2,3],[4,5,6]])

print(a.cumsum())            # 对整个矩阵求累积和
# 结果 [ 1  3  6 10 15 21]

print(a.cumsum(axis=0))  # 对行方向求累积和
# 结果
[[1 2 3]
 [5 7 9]]

print(a.cumsum(axis=1))  # 对列方向求累积和
# 结果
[[ 1  3  6]
 [ 4  9 15]]
```

#### 3.2.2 矩阵的截取

##### 按行列截取 

矩阵的截取和list相同，可以通过[]（方括号）来截取

```python
import numpy as np
a = np.array([[1,2,3,4,5],[6,7,8,9,10]])

print(a[0:1]) #截取第一行,返回 [[1 2 3 4 5]]
print(a[1,2:5]) #截取第二行，第三、四、五列，返回 [8 9 10]

print(a[1,:]) #截取第二行,返回 [ 6  7  8  9 10]
```

##### 按条件截取

```python
import numpy as np

a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
b = a[a>6] # 截取矩阵a中大于6的元素，范围的是一维数组
print(b) # 返回 [ 7  8  9 10]

# 其实布尔语句首先生成一个布尔矩阵，将布尔矩阵传入[]（方括号）实现截取
print(a>6)
# 返回
[[False False False False False]
 [False  True  True  True  True]]
```

按条件截取应用较多的是对矩阵中满足一定条件的元素变成特定的值。 
例如将矩阵中大于6的元素变成0。

```python
import numpy as np

a = np.array([[1,2,3,4,5],[6,7,8,9,10]])
print(a)
#开始矩阵为
[[ 1  2  3  4  5]
 [ 6  7  8  9 10]]

a[a>6] = 0
print(a)
#大于6清零后矩阵为
[[1 2 3 4 5]
 [6 0 0 0 0]]
```

##### clip截取

clip（矩阵，min，max）#返回值：所有小于min的值都等于min，所有大于max的值都等于max

```python
import numpy as np
array=np.array([[1,2,3],
                [4,5,6]])
print(array.clip(2,4))
#结果
# [[2 2 3]
#  [4 4 4]]
```



#### 3.2.3 矩阵的合并

矩阵的合并可以通过numpy中的hstack方法和vstack方法实现

水平Horizontal，垂直Vertical

```python
import numpy as np

a1 = np.array([[1,2],[3,4]])
a2 = np.array([[5,6],[7,8]])

#!注意 参数传入时要以列表list或元组tuple的形式传入
print(np.hstack([a1,a2]))
#横向合并，返回结果如下
[[1 2 5 6]
 [3 4 7 8]]

print(np.vstack((a1,a2)))
#纵向合并，返回结果如下
[[1 2]
 [3 4]
 [5 6]
 [7 8]]
```

矩阵的合并也可以通过concatenatef方法。

**np.concatenate( (a1,a2), axis=0 )  等价于  np.vstack( (a1,a2) )**

**np.concatenate( (a1,a2), axis=1 )  等价于  np.hstack( (a1,a2) )**` `





### 4. Pandas基操

#### 4.1 导入数据

```python
df= pd.read_csv(
    #该参数是数据在电脑里的路径，可以不填
    filepath_or_buffer = r"c:\Users\win 10\Desktop\sz000002.csv",
    
    #该参数代表数据的分隔符，csv文件默认为逗号，其他常见的"\t"
    sep= ',',
    
    #该参数代表跳过数据文件的第一行不读
    skiprows = 1,
    
    #nrows 只读前n行，若不指定，读取全部内容,
    nrows= 15,
    
    #将指定的列识别为日期格式，若不指定，时间数据将全会一字符串形式读入，
    #parse_dates= ['交易日期'],
    
    #将指定列设为index，若不指定，index 默认为0，1，2
    #index_col= ['交易日期'],
    
    #读取指定的几列数据，其他不读，若不指定，读入全部列
    usecols= ['交易日期','股票代码','股票名称','收盘价','成交量','涨跌幅','MACD_金叉死叉'],
    
    #当某行数据有问题，报错，设定false时，不报错直接跳过该行当数据比较脏乱的时候用这个
    error_bad_lines= False ,
    
    #将数据中的null识别为空值
    na_values= 'NULL'

)
```

**print(df) #使用pd.read.csv读取数据**

#### 4.2 看数据

```python
print(df.shape)      #输出dataframe 有多少行多少列
print(df.shape[0])   #取行数
print(df.shape[1])     #取列数
print(df.columns)          #顺序输出每一列的名字，是一个列表
print(df.index)       #顺序输出每一行的名字，
print(df.dtypes)      # 数据每一列的类型不一样，比如数字、字符串、日期等。该方法输出每一列变量类型
print(df.head(3))          #看前3行的数据，默认为5
print(df.tail(3))             #看最后3行的数据，默认为5
print(df.sample(frac=0.5))       #随机抽取3行，想要的固定比例的话，可以用frac参数
print(df.describe())           #非常方便的函数，对每一列数据有一个直管感受；只会对数字类型的列有效
```

**对print数据格式进行修正**

```python
pd.set_option('expand_frame_repr',False) # 当行太多时不换行
pd.set_option('max_colwidth',8) #设置每一行的最大宽度，恢复原设置方法pd.reset_option('max_colwidth')
print(df) #  如何选取指定列制定行读取数据

print( df['股票代码'])  # 根据列名称来选取，读取的数据是Series类型
print (df[['股票代码', '收盘价']])  # 同时选取多列，需要两个括号，读取的数据是DataFrame类型
print (df[[0,1,2]])  # 也可以通过列的position来选取(出现错误提示not in index)
```

**loc 操作** ：通过**label**（**columns**和**index**的名字）来读取数据

```python
print(df.loc['09/12/2016'])  #选取指定的某一行，读取的数据是series类型的
print(df.loc['13/12/2016': '06/12/2016'])  # 选取在此范围内的多行，和在list中slice操作类似，读取的数据是DataFrame类型
print(df.loc[:, '股票代码':'收盘价'] ) # 选取在此范围内的多列，读取的数据是DataFrame类型
print(df.at['12/12/2016', '股票代码'] ) # 使用at读取指定的某个元素。loc也行，但是at更高效。

```

**iloc** 通过**position**来读取数据

```python
print(df.iloc[0]) # 以index选取某一行，读取的数据是Series类型
print(df.iloc[1:3])  # 选取在此范围内的多行，读取的数据是DataFrame类型
print(df.iloc[:, 1:3])  # 选取在此范围内的多列，读取的数据是DataFrame类型
print(df.iloc[1:3, 1:3]) # 读取指定的多行、多列，读取的数据是DataFrame类型
print(df.iloc[:, :]) # 读取所有行、所有列，读取的数据是DataFrame类型
print(df.iat[1, 1])  # 使用iat读取指定的某个元素。使用iloc也行，但是iat更高效。
```

#### 4.3 列操作

**行列加减乘除**

```python
print(df['股票名称'] + '_地产')       # 字符串列可以直接加上字符串，对整列进行操作
print(df['收盘价'] * 100)           # 数字列直接加上或者乘以数字，对整列进行操作。
print(df['收盘价'] * df['成交量'])      # 两列之间可以直接操作。收盘价*成交量计算出的是什么？

df['股票名称+行业'] = df['股票名称'] + '_地产'      # 新增一列
print(df)
```

#### 4.4 统计函数

```python
print(df['收盘价'].mean())  # 求一整列的均值，返回一个数。会自动排除空值。
print( df[['收盘价', '成交量']].mean())  # 求两列的均值，返回两个数，Series
print (df[['收盘价', '成交量']])
print( df[['收盘价', '成交量']].mean(axis=0) ) # 求两列的均值，返回DataFrame。axis=0或者1要搞清楚。
axis=1，代表对整几列进行操作。axis=0（默认）代表对几行进行操作。实际中弄混很正常，到时候试一下就知道了。

print(df['收盘价'].max()) # 最大值
print(df['收盘价'].min())  # 最小值
print(df['收盘价'].std())  # 标准差
print(df['收盘价'].count())  # 非空的数据的数量
print(df['收盘价'].median())  # 中位数
print(df['收盘价'].quantile(0.25))  # 25%分位数

# 肯定还有其他的函数计算其他的指标，在实际使用中遇到可以自己搜索
```

#### 4.5 shift类函数、删除列的方式

```python
df['昨天收盘价'] = df['收盘价'].shift(3)  # 读取上一行的数据，若参数设定为3，就是读取上三行的数据；若参数设定为-1，就是读取下一行的数据；
print(df[['收盘价','昨天收盘价']])

del df['昨天收盘价']  # 删除某一列的方法
print(df)

df['涨跌'] = df['收盘价'].diff(-1)  # 求本行数据和上一行数据相减得到的值
print(df[['收盘价', '涨跌']])
df.drop(['涨跌'], axis=1, inplace=True)  # 删除某一列的另外一种方式，inplace参数指是否替代原来的df
print (df)  
df['涨跌幅_计算'] = df['收盘价'].pct_change(-1)  # 类似于diff，但是求的是两个数直接的比例，相当于求涨跌幅
print(df)
```

[Pandas-基本操作教程_识醉沉香的博客-CSDN博客_pandas基本操作](https://blog.csdn.net/qq_43283527/article/details/82898490)



### 5. 常用代码

#### 5.1 python拟合曲线

```python

y = [434.506,330.688,509.525,234.044,327.325,553.256,432.656,197.325,408.394,322.794,284.631,375.562,277.25,262.35,474.675,348.894,298.025,452.212,469.775,337.994,380.763,412.05,222.556,371.669,396.456,341.888,368.319,293.231,507.906,443.581,321.587,452.769,374.25,369.431,404.019,342.237,471.831,423.175,267.712,292.875,388.731,307.112,428.15,359.288,503.388,260.481,372.706,676.713,345.812,450.356,390.1,424.481,433.688,312.8,412.231,506.425,499.7,392.269,517.094,258.788,551.775,366.625,272.625,451.962,368.35,172.637,482.194,369.694,398.987,379.675,430.175,338.031,335.019,363.656,389.256,349.3,432.125,438.944,451.681,358.781,364.925,407.194,539.869,482.612,396.038,472.812,413.825,297.331,587.737,457.7,553,348.025,474.094,508.712,346.625,320.756,585.138,397.625,561.931,440.919,485.344,370.906,415.219,487.656,320.619,492.681,551.394,392.856,465.925,362.175,521.1,377.944,457.556,425.025,343.619,329,497.219,416.737,479.356,614.431,523.925,535.438,492.094,790.65,272.462,457.244,592.875,459.337,519.681,623.831,570.619,555.638,468.156,434.981,578.631,323.062,545.081,545.519,564.362,522.694,593.2,600.106,633.756,465.881,541.662,587.619,624.031,586.5,614.419,502.763,653.944,454.631,628.025,492.95,597.1,487.788,472.35,624.206,525.375,661.119,627.681,557.575,586.681,532.287,561.838,728.737,583.15,551.881,520.625,712.619,529.619,648.719,528.106,552.688,553.75,735.669,583.506,585.294,603.194,658.325,543.312,625.969,514.9,671.831,621.45,720.812,585.112,705.394,583.775,669.519,598.706,680.688,716.169,560.225,765.119,739.838,593.95,744.5,756.175,808.856,638.156,931.806,933.869,903.844,992.812,1205.675,1142.131,1313.506,1367.669,1482.412,1595.637,1860.206,1768.713,2115.469,2115.394,2327.625,2390.969,2472.637,2487.094,2653.681,2717.119,2751.837,2684.131,2811.206,2848.275,2891.438,2933.387,2942.775,2989.944,2887.062,3036.538,2935.863,2949.131,3187.387,2806.95,2897.781,3115.281,3078.106,3076.387,3056.481,2981.387,3029.031,3001.156,3060.256,2833.262,2933.019,3021.812,3024.8,3036.494,3095.012,3025.406,3195.837,3148.231,3111.356,3104.856,3031.837,3033.587,3115.325,2956.663,3015.694,3048.944,3040.413,3021.087,2948.806,3137.094,3104.762,2977.038,2908.806,3129.6,3057.719,3077.706,3054.294,3094.225,3170.731,3012.438,2944.25,3086.569,3189.694,3085.456,3119.056,3170.156,3112.538,3149.825,3229.45,3183.4,3226.406,3117.869,3178.625,3192.231,3370.744,3059.944,3280.975,3257.075,3345.906,3194.413,3126.181,3158.094,3291.6,3133.256,3224.794,3192.231,3313.925,3248.3,3209.725,3218.575,3373.381,3205.175,3207.525,3220.281,3162.938,3259.038,3179.281,3314.4,3386.931,3218.788,3134.762,3319.344,3122.856,3224.275,3332.144,3226.356,3397.038,3176.275,3278.319,3087.488,3215.587,3078.3,3157.562,2901.988,3262.1,3161.837,3183.938,3140.606,3288.45,2895.775,3190.337,3133.131,3123.925,3092.381,3064.55,3133.613,2985.775,3025.7,2820.637,2718.462,2526.375,2438.231,2163.163,2197.169,1737.406,1633.981,1285.256,1246.9,942.188,927.662,554.475,711.463,586.175,342.888,394.444,411.587,246.769,216.312,305.85,372.175,337.681,181.75,470.969,329.444,332.112,502.381,139.538]
x = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371]

z1 = np.polyfit(x, y, 30)#用30次多项式拟合
p1 = np.poly1d(z1)
print(p1) #在屏幕上打印拟合多项式
yvals=p1(x)#也可以使用yvals=np.polyval(z1,x)
plot1=plt.plot(x, y, '*',label='original values')
plot2=plt.plot(x, yvals, 'r',label='polyfit values')
plt.xlabel('x axis')
plt.ylabel('y axis')
plt.legend(loc=4)#指定legend的位置,读者可以自己help它的用法
plt.title('polyfitting')
plt.show()
plt.savefig('p1.png')
```

获取半高宽：

```python
y = np.array([434.506,330.688,509.525,234.044,327.325,553.256,432.656,197.325,408.394,322.794,284.631,375.562,277.25,262.35,474.675,348.894,298.025,452.212,469.775,337.994,380.763,412.05,222.556,371.669,396.456,341.888,368.319,293.231,507.906,443.581,321.587,452.769,374.25,369.431,404.019,342.237,471.831,423.175,267.712,292.875,388.731,307.112,428.15,359.288,503.388,260.481,372.706,676.713,345.812,450.356,390.1,424.481,433.688,312.8,412.231,506.425,499.7,392.269,517.094,258.788,551.775,366.625,272.625,451.962,368.35,172.637,482.194,369.694,398.987,379.675,430.175,338.031,335.019,363.656,389.256,349.3,432.125,438.944,451.681,358.781,364.925,407.194,539.869,482.612,396.038,472.812,413.825,297.331,587.737,457.7,553,348.025,474.094,508.712,346.625,320.756,585.138,397.625,561.931,440.919,485.344,370.906,415.219,487.656,320.619,492.681,551.394,392.856,465.925,362.175,521.1,377.944,457.556,425.025,343.619,329,497.219,416.737,479.356,614.431,523.925,535.438,492.094,790.65,272.462,457.244,592.875,459.337,519.681,623.831,570.619,555.638,468.156,434.981,578.631,323.062,545.081,545.519,564.362,522.694,593.2,600.106,633.756,465.881,541.662,587.619,624.031,586.5,614.419,502.763,653.944,454.631,628.025,492.95,597.1,487.788,472.35,624.206,525.375,661.119,627.681,557.575,586.681,532.287,561.838,728.737,583.15,551.881,520.625,712.619,529.619,648.719,528.106,552.688,553.75,735.669,583.506,585.294,603.194,658.325,543.312,625.969,514.9,671.831,621.45,720.812,585.112,705.394,583.775,669.519,598.706,680.688,716.169,560.225,765.119,739.838,593.95,744.5,756.175,808.856,638.156,931.806,933.869,903.844,992.812,1205.675,1142.131,1313.506,1367.669,1482.412,1595.637,1860.206,1768.713,2115.469,2115.394,2327.625,2390.969,2472.637,2487.094,2653.681,2717.119,2751.837,2684.131,2811.206,2848.275,2891.438,2933.387,2942.775,2989.944,2887.062,3036.538,2935.863,2949.131,3187.387,2806.95,2897.781,3115.281,3078.106,3076.387,3056.481,2981.387,3029.031,3001.156,3060.256,2833.262,2933.019,3021.812,3024.8,3036.494,3095.012,3025.406,3195.837,3148.231,3111.356,3104.856,3031.837,3033.587,3115.325,2956.663,3015.694,3048.944,3040.413,3021.087,2948.806,3137.094,3104.762,2977.038,2908.806,3129.6,3057.719,3077.706,3054.294,3094.225,3170.731,3012.438,2944.25,3086.569,3189.694,3085.456,3119.056,3170.156,3112.538,3149.825,3229.45,3183.4,3226.406,3117.869,3178.625,3192.231,3370.744,3059.944,3280.975,3257.075,3345.906,3194.413,3126.181,3158.094,3291.6,3133.256,3224.794,3192.231,3313.925,3248.3,3209.725,3218.575,3373.381,3205.175,3207.525,3220.281,3162.938,3259.038,3179.281,3314.4,3386.931,3218.788,3134.762,3319.344,3122.856,3224.275,3332.144,3226.356,3397.038,3176.275,3278.319,3087.488,3215.587,3078.3,3157.562,2901.988,3262.1,3161.837,3183.938,3140.606,3288.45,2895.775,3190.337,3133.131,3123.925,3092.381,3064.55,3133.613,2985.775,3025.7,2820.637,2718.462,2526.375,2438.231,2163.163,2197.169,1737.406,1633.981,1285.256,1246.9,942.188,927.662,554.475,711.463,586.175,342.888,394.444,411.587,246.769,216.312,305.85,372.175,337.681,181.75,470.969,329.444,332.112,502.381,139.538])
x = np.array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371])
z1 = np.polyfit(x, y,30)#用3次多项式拟合
p1 = np.poly1d(z1)
print(p1) #在屏幕上打印拟合多项式
yvals=p1(x)#也可以使用yvals=np.polyval(z1,x)
plot1=plt.plot(x, y, '*',label='original values')
plot2=plt.plot(x, yvals, 'r',label='polyfit values')
plt.xlabel('x axis')
plt.ylabel('y axis')
plt.legend(loc=4)#指定legend的位置,读者可以自己help它的用法
plt.title('polyfitting')
plt.plot([min_xs,max_xs],[y[min_xs],y[min_xs]],'bo--')
max_y = max(y)  # Find the maximum y value
xs = [x for x in range(350) if y[x] > max_y/2.0]
min_xs = min(xs)
max_xs = max(xs)
print("左：({},{})， 右：({},{})".format(min_xs,y[min_xs],max_xs,y[max_xs]))
print("半高宽：{}".format(max(xs)-min(xs)))


plt.show()
plt.savefig('p1.png')
```

